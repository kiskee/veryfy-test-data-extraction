import os
import re
import veryfi
import json


class Read:
    """
    Attributes:
        multi = Flag to pass in the re module as multine
        dic = list of all the files json
        files = List of the names of the files to process
    """
    multi = re.M
    dic = []
    files = []

    def __init__(self, folder_path, client_id, client_secret, username, api_key):
        """
        The __init__ method is called automatically when an instance of the class is created,
        initializes the instance's attributes with default or user-supplied values.
        :param  folder_path: the path of the folder you want to scan
        :param client_id: client_id is a unique code used to authenticate and authorize a client's access to Veryfi's API services.
        :param client_secret: is a private key known only to you/your application and the authorization server.
        :param username: The username is a unique identifier used to identify an individual user's account in Veryfi's platform
        :param api_key: is a unique code generated by Veryfi that is used to authenticate a client's access to the Veryfi API services
        """
        self.folder_path = folder_path
        self.client_id = client_id
        self.client_secret = client_secret
        self.username = username
        self.api_key = api_key

        # Instance the client from Veryfi
        self.client = veryfi.Client(self.client_id, self.client_secret, self.username, self.api_key)

    def get_file_names(self):
        """
        This method scans the folder provided when instantiating the class and will return
         the names of the files to be scanned.
        :return: (list) with all names of files in the folder
        """
        file_names = os.listdir(self.folder_path)
        self.files = file_names
        return file_names

    def get_ocr_text(self, dic):
        """
        This method will allow us to correctly extract the orc_text for dictionary given
        :param dic: Dictionary to work
        :return:(srt) The string of the ocr_text
        """
        if 'ocr_text' in dic:
            return dic['ocr_text']
        else:
            return None

    def get_vendor_name(self, dic):
        """
        This method obtains the orc_text in the given dictionary, then with the regular expression
        created it makes a search for all the ocr_text, then joins the first 4 results with a space
        and these generate the vendor_name, given the format of the files
        :param dic: Dictionary to work
        :return:(str) The vendor_name
        """
        orc_text = self.get_ocr_text(dic)
        # Regular expresion to get the vendor name in the ocr_text
        regex = r"^([A-Z]{3,})(?:\t{1,}).+"
        try:
            result = re.findall(regex, orc_text, self.multi)
            vendor_name = ' '.join(map(str, result[:4])).strip()
        except IndexError:
            vendor_name = None

        if vendor_name != 'THE AMERICAN TOBACCO COMPANY':
            return None
        return vendor_name

    def get_bill_to_name(self, dic):
        """
        This method gets the orc_text in the given dictionary, then with the regular
        expression created it does a search for all the ocr_text, and returns us the
        clean bill_to_name
        :param dic: Dictionary to work
        :return: (str) The bill_to_name
        """
        orc_text = self.get_ocr_text(dic)
        # Regular expresion to get the bill_to_name in the ocr_text
        regex = r"(?<=(?:ATTN|Atta):)([\w .]+)"
        try:
            bill_to_name = re.findall(regex, orc_text)[0].strip()
        except IndexError:
            bill_to_name = None
        return bill_to_name

    def get_bill_to_address(self, dic):
        """
        This method gets the orc_text in the given dictionary, then with the regular
        expression created it does a search for all the ocr_text, and returns us the
        clean bill_to_address
        :param dic: Dictionary to work
        :return: (str) The bill_to_address
        """
        orc_text = self.get_ocr_text(dic)
        # Regular expresion to get the bill_to_address in the ocr_text
        regex = r"(.+(?:Street|Avenue).+\s.+\s|.+\s)(.+\, \w{2} \d{5})"
        result = re.findall(regex, orc_text, self.multi)
        if len(result) > 0:
            # We need to clean the result of the search due to having some characters that we don't need
            formated_list = list(result[0])
            line1 = formated_list[0].split('\t\t')[0].split('\n')[0].replace('P	', '')
            return f"{line1} {formated_list[1]}"
        else:
            return None

    def get_ship_to_name(self, dic):
        """
        This method gets the orc_text in the given dictionary, then with the regular
        expression created it does a search for all the ocr_text, and returns us the
        clean ship_to_name
        :param dic: Dictionary to work
        :return: (srt) The ship_to_name
        """
        orc_text = self.get_ocr_text(dic)
        # Regular expresion to get the ship_to_name in the ocr_text
        regex = r"(?<=(?:\t(?:ATTN|Atta)): )([\w .]+)$"
        try:
            ship_to_name = re.findall(regex, orc_text, self.multi)[0].strip()
        except IndexError:
            ship_to_name = None
        return ship_to_name

    def get_ship_to_address(self, dic):
        """
        This method gets the orc_text in the given dictionary, then with the regular
        expression created it does a search for all the ocr_text, and returns us the
        clean ship_to_address
        :param dic: Dictionary to work
        :return: (srt) The ship_to_address
        """
        orc_text = self.get_ocr_text(dic)
        # Regular expresion to get the ship_to_address in the ocr_text
        regex = r"(?:\t(\d.+)\s.+P\s)(.+\w{2}\s\d{5})$"
        try:
            response = re.findall(regex, orc_text, self.multi)
            formated_response = list(response[0])
            # Validate is the formated_response have values
            if len(formated_response) > 0:
                ship_to_address = ' '.join(map(str, formated_response[:2])).strip()
            else:
                ship_to_address = None
        except IndexError:
            ship_to_address = None
        return ship_to_address

    def get_quantity_and_price(self, dic):
        """
        This method gets the orc_text in the given dictionary, then with the regular
        expression created it does a search for all the ocr_text, and returns us a
        list with quantity and price values
        :param dic: Dictionary to work
        :return: (list) A list with quantity and price values
        """
        orc_text = self.get_ocr_text(dic)
        # Regular expresion to get the quantity and price values in the ocr_text
        regex = r"(?:PRICE$)(?:\n|.+\n)+\s^([\d,]+)(?:\t.+)\$([\d.]+) (?:each|ea)"
        # Regex to get only the quantity
        # regex = r"(?:PRICE$)(?:\n|.+\n)+\s^([\d,]+)(?:\t)"
        try:
            result = re.search(regex, orc_text, self.multi)
            # Validate if the result is not None
            if result is not None:
                result = result.groups()
            else:
                result = None
        except IndexError:
            result = None
        return result

    def get_item_description(self, dic):
        """
        This method gets the orc_text in the given dictionary, then with the regular
        expression created it does a search for all the ocr_text, and returns us the
        clean ship_to_address
        :param dic: Dictionary to work
        :return: (str) The item description
        """
        orc_text = self.get_ocr_text(dic)
        # Regular expresion to get the description in the ocr_text
        regex = r"PRICE([\n\d\w\D]*)(\n\d[\d,]+)(.+\s+)\$.+(?:each|ea)\n((.+\s)+)(?:.$\n|^(?:\n|\t))"
        result = re.search(regex, orc_text, self.multi)
        # Validate if the result is not None
        if result is not None:
            groups = result.groups()
            ne = [groups[0].strip(), groups[2].strip(), groups[3].strip()]
            res = ' '.join(ne)
            clean = str(res).replace('\n', '').replace('\t', '').replace('"', "")
        else:
            clean = None
        return clean

    def create_line_items(self, dic):
        """
        This method creates a dictionary for us by calling the methods themselves to obtain
        the line items, such as quantity, description and price.
        :param dic: Dictionary to work
        :return: (dict) A dictionary with the line_items: quantity, description and price
        """
        # Call self methods for get the line items
        q_and_p = self.get_quantity_and_price(dic)
        description = self.get_item_description(dic)
        new_dic = {}
        # Validate if the valuare are not None
        if q_and_p is not None and description is not None:
            new_dic['quantity'] = q_and_p[0].strip()
            new_dic['Description'] = description.strip()
            new_dic['price'] = q_and_p[1].strip()
        else:
            new_dic = None
        return new_dic

    def create_json_return(self, dic):
        """
        This method uses all the previous methods to get the values and
        create a dictionary with them. After that we convert it to JSON
        format to be returned
        :param dic: Dictionary to work
        :return: (json) a JSON with all the requested information
        """
        vendor_name = self.get_vendor_name(dic)
        # Validate the vendor name. at this point we validate that all invoices are from the same vendor
        if vendor_name is not None:
            json_return = {'vendor_name': self.get_vendor_name(dic), 'bill_to_name': self.get_bill_to_name(dic),
                           'bill_to_address': self.get_bill_to_address(dic), 'ship_to_name': self.get_ship_to_name(dic),
                           'ship_to_address': self.get_ship_to_address(dic), 'line_items': self.create_line_items(dic)}
        else:
            json_return = {'Error': 'The file does not match the requested format'}
        return json.dumps(json_return)

    def process_files(self):
        """
        the method process_files() takes a list of file names, located in a folder
        specified by self.folder_path, and processes each file using self.client.process_document().
        The resulting dictionaries are stored in a list set_of_dic and returned by the method.
        :return:
        """
        file_paths = []
        set_of_dic = []
        for item in self.get_file_names():
            path = f"{self.folder_path}{item}"
            file_paths.append(path)
        for file in file_paths:
            dic = self.client.process_document(file)
            set_of_dic.append(dic)
        self.dic = set_of_dic
        return set_of_dic

    def get_all_data_from_file(self):
        """
        This method will call the function of process_files and for each File it will print the final JSON
        :return: print a JSON file for each file
        """
        self.process_files()
        for file in self.dic:
            print(self.create_json_return(file))


# In the event that you need to test the class through code. Example execution: python Read.py
if __name__ == "__main__":
    # Complete the following with your personal information from Veryfi
    invo = Read(
        'your folder path', 'your CLIENT ID', 'your CLIENT SECRET',
        'your USERNAME',
        'your API KEY'
    )
    invo.get_all_data_from_file()
